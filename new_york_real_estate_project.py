# -*- coding: utf-8 -*-
"""New York Real estate Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T2S4aq2uHMgscZ_cLL7Gs9wqEEWgVksQ
"""

import pandas as pd #import pandas

#upload files
from google.colab import files
uploaded = files.upload()

pd.read_csv('NY-House-Dataset.csv') #Show dataset to make sure it works

df = pd.read_csv('NY-House-Dataset.csv') #Creating dataframe and naming it df

df.head(6) #ensuring dataframe correctly created, showing first 6 rows of data

df_clone = pd.DataFrame(df) #creating clone of dataframe and naming as df_clone

df_clone = df.reindex(columns = ['BROKERTITLE','TYPE','PRICE','BEDS','BATH','PROPERTYSQFT','ADDRESS','STATE']) #reindex / removing columns not needed

df_clone['BROKERTITLE'] = df_clone['BROKERTITLE'].str.replace('Brokered by', '', regex=False) #removing the words 'brokered by' in column 1

df_clone #retrieving clone

df_clone = df_clone[df_clone['PROPERTYSQFT'] != 2184.207862] #dropping rows in dataframe where propertysqft is 2184.207862 due to too many rows of data consisting exactly of 2184.207862 - outliers

df_clone

df_clone['ZIP'] = df_clone['STATE'].str[-5:] #creating zip code column

df_clone #retrieving clone

df_clone.groupby('TYPE')['TYPE'].count() #count

df_clone.groupby('TYPE')['PRICE'].describe() #describe

#unknown_borough_rows = df_clone[unknown_boroughs]
#unknown_borough_rows
#unique_zips = df_clone[unknown_boroughs]['ZIP'].unique()
#print(unique_zips)
#looping through zip codes and assigning it a Borough based on zip code
def borough(zipcode):
    if 11201 <= zipcode <= 11256:
        return "Brooklyn"
    elif zipcode in [
        11101, 11102, 11103, 11104, 11105, 11106, 11109, 11120,
        11354, 11355, 11356, 11357, 11358, 11360, 11361, 11362,
        11363, 11364, 11365, 11366, 11367, 11368, 11369, 11370,
        11372, 11373, 11374, 11375, 11377, 11378, 11379, 11385,
        11411, 11412, 11413, 11414, 11415, 11416, 11417, 11418,
        11419, 11420, 11421, 11422, 11423, 11426, 11427, 11428,
        11429, 11432, 11433, 11434, 11435, 11436,
        11691, 11692, 11693, 11694, 11695, 11697,
        11005, 11004, 11040, 11001
    ]:
        return "Queens"
    elif 10301 <= zipcode <= 10314:
        return "Staten Island"
    elif 10451 <= zipcode <= 10475:
        return "Bronx"
    elif zipcode in [
        10001, 10002, 10003, 10004, 10005, 10006, 10007, 10009, 10010,
        10011, 10012, 10013, 10014, 10016, 10017, 10018, 10019, 10020,
        10021, 10022, 10023, 10024, 10025, 10026, 10027, 10028, 10029,
        10030, 10031, 10032, 10033, 10034, 10035, 10036, 10037, 10038,
        10039, 10040, 10044, 10045, 10055, 10065, 10069, 10075, 10103,
        10110, 10111, 10112, 10115, 10119, 10128, 10162, 10165, 10167,
        10168, 10169, 10170, 10171, 10172, 10173, 10174, 10177, 10271,
        10278, 10279, 10280, 10281, 10282
    ]:
        return "Manhattan"
    else:
        return "Unknown"

df_clone['ZIP'] = df_clone['ZIP'].astype(int) # convert zipcode from str to int

df_clone['Borough'] = df_clone['ZIP'].apply(borough) # creating Borough column and assigning the borough using borough function above

df_clone

df_clone['Borough'].unique() #ensuring Boroughs were correctly looped and no unknown/other values

df_clone['TYPE'].unique()

summary = df_clone.groupby("Borough")["PRICE"].describe() #description of prices grouped by boroughs

summary = summary.round(0) #rounding

summary #summarizing the data

summary['max'] = summary['max'].round(0)

summary #checking max amounts for each borough

summary_type = df_clone.groupby("TYPE")["PRICE"].describe() #description of prices grouped by type of residence

summary_type = summary_type.round(0)

summary_type

unique_counts = df_clone['TYPE'].count()
print(unique_counts)

df_clone.groupby('TYPE')['PRICE'].mean().plot(kind = 'bar', xlabel = 'Property Type', ylabel = 'Average Price', title= 'Average Price per Property Type')  #graphing average price per type

df_clone.groupby('Borough')['PRICE'].mean().plot(kind = 'bar', xlabel = 'Borough', ylabel = 'Average Price', title= 'Average Price per Borough') #graphing average price per borough

df_clone.groupby('Borough')['PRICE'].max().plot(kind = 'bar', xlabel = 'Borough', ylabel = 'Max Price', title= 'Max Price per Borough') #graphing max price per borough

df_clone.groupby('TYPE')['PRICE'].max().plot(kind = 'bar', xlabel = 'Property type', ylabel = 'Max Price', title= 'Max Price per Type') #graphing max price per type of residence

df_clone.groupby('BEDS')['PRICE'].mean().plot(kind = 'bar', xlabel = 'Amount of beds', ylabel = 'Mean Price', title= 'Mean Price per Beds') #showing average price per bed/bedrooms

import pandas as pd
from scipy.stats import linregress

# df_clone and propertySQFT and price
x = df_clone['PRICE']
y = df_clone['PROPERTYSQFT']

# Perform linear regression
slope, intercept, r_value, p_value, std_err = linregress(x, y)

# Output the results
print(f"Slope: {slope}")
print(f"Intercept: {intercept}")
print(f"R-squared: {r_value**2}")
print(f"P-value: {p_value}")
print(f"Standard error: {std_err}")

#scatterplot of price per sqft
import matplotlib.pyplot as plt

# Plot the scatter plot
plt.scatter(df_clone['PRICE'], df_clone['PROPERTYSQFT'], color='red', marker='o')
plt.xlabel('PRICE')
plt.ylabel('SQFT')
plt.title('Scatterplot of Property Square Footage vs Price')
plt.xlim(100000,600000)
plt.ylim(1000,3000)
plt.show()

import matplotlib.pyplot as plt

# Plot the scatter plot
plt.scatter(df_clone['PRICE'], df_clone['PROPERTYSQFT'], color='red', marker='o')
plt.xlabel('PRICE')
plt.ylabel('SQFT')
plt.title('Scatterplot of Property Square Footage vs Price')
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter

df_clone_price_perbath = df_clone.groupby('BATH')['PRICE'].mean().plot(kind = 'bar',xlabel = 'Amount of Baths', ylabel = 'Max Price', title= 'Mean Price per Amount of Baths')
def format_ticks(value, tick_number):
    return f"{value:.1f}"
df_clone_price_perbath.xaxis.set_major_formatter(FuncFormatter(format_ticks))
plt.show()

import sqlite3

conn = sqlite3.connect('NYC_real_estate.db') #creating housing database file

df_clone.to_sql('Housing', conn, if_exists='replace', index=False) #create a table named Housing into Housing database created above

Query1 = pd.read_sql_query("SELECT * FROM Housing", conn) #creating first query

Query1 #display first query

Query2 = pd.read_sql_query("SELECT * FROM Housing where PRICE > 100000000", conn) #second query

Query2 #display second query

Query3 = pd.read_sql_query("SELECT * FROM Housing where TYPE = 'Condo for sale' order by PRICE desc;", conn) #third query

Query3 #display third query

df_clone

#checking p values and coefficients within multi-regression model
import statsmodels.formula.api as smf

model = smf.ols(formula='PRICE ~   BEDS + BATH + PROPERTYSQFT', data=df_clone).fit()

print(model.summary())

# Define a price threshold (e.g., 95th percentile)
price_threshold = df_clone['PRICE'].quantile(0.90)

# Filter the data to exclude prices above the threshold
filtered_data = df_clone[df_clone['PRICE'] <= price_threshold]

# Plot the histogram with filtered data
filtered_data['PRICE'].plot(kind = 'hist',bins=25, title='Filtered Distribution of Property Prices',figsize = (10,6), color='skyblue')
plt.xlabel('Price (in $)')
plt.ylabel('Frequency')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# Boxplot: Detecting Outliers in Prices
df_clone['PRICE'].plot.box(title='Boxplot of Property Prices', figsize=(10, 6), vert=False, color='lightgreen')
plt.xlabel('Price (in $)')
plt.show()

#create location scatterplot based on latitude and longitude
df.plot(kind = 'scatter',x='LONGITUDE', y='LATITUDE', figsize=(10, 6), color='black', alpha=.5, edgecolor = 'white')
plt.title('Scatter Plot of Latitude vs Longitude')
plt.xlabel('LONGITUDE')
plt.ylabel('LATITUDE')
plt.show()